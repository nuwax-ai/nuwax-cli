---
name: CLI-UI Build & Release

# ðŸš€ CLI-UI æ¡Œé¢åº”ç”¨æž„å»ºå’Œå‘å¸ƒè¯´æ˜Ž:
# 1. æž„å»º Duck CLI GUI æ¡Œé¢åº”ç”¨ï¼Œå†…ç½® nuwax-cli ä½œä¸º sidecar
# 2. åŸºäºŽ CLI-UI ç‰ˆæœ¬å˜åŒ–è‡ªåŠ¨è§¦å‘æž„å»ºå’Œå‘å¸ƒ
# 3. nuwax-cli ä»…ä½œä¸ºå†…åµŒç»„ä»¶æž„å»ºï¼Œä¸å•ç‹¬å‘å¸ƒ
# 4. ä½¿ç”¨å®˜æ–¹ tauri-action ç®€åŒ–æž„å»ºæµç¨‹ï¼Œè‡ªåŠ¨å¤„ç†ç­¾åå’Œæ›´æ–°
# 5. æ”¯æŒè·¨å¹³å°ï¼šLinux, Windows, macOS (Intel & Apple Silicon)
# 6. ðŸ–¥ï¸ è‡ªå®šä¹‰Runneré…ç½®:
#    - Windows: [self-hosted, Windows, X64] - ä½¿ç”¨SODDY runner
#    - macOS: [self-hosted, macOS, ARM64] - ä½¿ç”¨soddys-Mac-mini runner  
#    - Linux: ç»§ç»­ä½¿ç”¨GitHubæ‰˜ç®¡çš„ubuntu runner

on:
  push:
    branches: [main]
    paths:
      - 'nuwax-cli/**'
      - 'client-core/**'
      - 'cli-ui/**'
      - '.github/workflows/cli-ui-build.yml'
  pull_request:
    branches: [main]
    paths:
      - 'duck-cli/**'
      - 'client-core/**'
      - 'cli-ui/**'
      - '.github/workflows/cli-ui-build.yml'
  workflow_dispatch:
    inputs:
      force_cli_ui_release:
        description: 'Force release CLI-UI even if version unchanged'
        required: false
        default: false
        type: boolean

# æ·»åŠ å¿…è¦çš„æƒé™é…ç½®
permissions:
  contents: write  # éœ€è¦å†™æƒé™æ¥åˆ›å»º release
  actions: read

env:
  CARGO_TERM_COLOR: always
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}

jobs:
  # æ£€æŸ¥ç‰ˆæœ¬å˜åŒ–å’Œå†³å®šå‘å¸ƒç­–ç•¥
  check-versions:
    name: Check Versions & Release Strategy
    runs-on: ubuntu-latest
    outputs:
      # CLI-UI ç›¸å…³è¾“å‡º
      cli_ui_version: ${{ steps.cli_ui_check.outputs.version }}
      cli_ui_tag_name: ${{ steps.cli_ui_check.outputs.tag_name }}
      cli_ui_should_release: ${{ steps.cli_ui_check.outputs.should_release }}
      
      # æž„å»ºç­–ç•¥
      should_build: ${{ steps.build_strategy.outputs.should_build }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # èŽ·å–å®Œæ•´åŽ†å²ä»¥æ£€æŸ¥çŽ°æœ‰ tags



      - name: Check CLI-UI version
        id: cli_ui_check
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          # ä»Ž cli-ui/src-tauri/tauri.conf.json è¯»å–ç‰ˆæœ¬å·
          VERSION=$(cat cli-ui/src-tauri/tauri.conf.json | grep '"version"' | head -1 | sed 's/.*"version": "\(.*\)".*/\1/')
          TAG_NAME="cli-ui-v${VERSION}"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ æ£€æµ‹åˆ° CLI-UI ç‰ˆæœ¬: ${VERSION}"
          echo "ðŸ“‹ å¯¹åº”æ ‡ç­¾: ${TAG_NAME}"
          
          # æ£€æŸ¥è¿™ä¸ªç‰ˆæœ¬çš„ tag æ˜¯å¦å·²ç»å­˜åœ¨
          if git tag -l | grep -q "^${TAG_NAME}$"; then
            echo "âš ï¸ CLI-UI æ ‡ç­¾ ${TAG_NAME} å·²å­˜åœ¨"
            if [[ "${{ github.event.inputs.force_cli_ui_release }}" == "true" ]]; then
              echo "ðŸ”§ å¼ºåˆ¶å‘å¸ƒ CLI-UI (æ‰‹åŠ¨è§¦å‘)"
              echo "should_release=true" >> $GITHUB_OUTPUT
            else
              echo "ðŸ“¦ CLI-UI ç‰ˆæœ¬ ${VERSION} å·²å‘å¸ƒï¼Œè·³è¿‡"
              echo "should_release=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âœ… å‘çŽ° CLI-UI æ–°ç‰ˆæœ¬ ${VERSION}ï¼Œå‡†å¤‡å‘å¸ƒ"
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine build strategy
        id: build_strategy
        run: |
          # å¦‚æžœæ˜¯ main åˆ†æ”¯ä¸” CLI-UI éœ€è¦å‘å¸ƒï¼Œæˆ–è€…æ˜¯ PRï¼Œéƒ½éœ€è¦æž„å»º
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            if [[ "${{ steps.cli_ui_check.outputs.should_release }}" == "true" ]]; then
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "ðŸš€ Main åˆ†æ”¯æ£€æµ‹åˆ° CLI-UI æ–°ç‰ˆæœ¬ï¼Œå¼€å§‹æž„å»º"
            else
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "ðŸ“¦ Main åˆ†æ”¯æ—  CLI-UI æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡æž„å»º"
            fi
          else
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "ðŸ”§ PR æˆ–å…¶ä»–åˆ†æ”¯ï¼Œæ‰§è¡Œæž„å»ºç”¨äºŽæµ‹è¯•"
          fi

  # æž„å»º Duck CLI äºŒè¿›åˆ¶æ–‡ä»¶
  build-nuwax-cli:
    name: Build Duck CLI for ${{ matrix.platform.name }}
    runs-on: ${{ matrix.platform.os }}
    needs: check-versions
    if: needs.check-versions.outputs.should_build == 'true'
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        platform:
          - name: Linux-x86_64
            os: ubuntu-22.04
            rust_target: x86_64-unknown-linux-gnu
            duck_cli_bin: nuwax-cli
            duck_cli_archive: nuwax-cli-linux-amd64.tar.gz
            cross: false

          - name: Linux-aarch64
            os: ubuntu-22.04
            rust_target: aarch64-unknown-linux-gnu
            duck_cli_bin: nuwax-cli
            duck_cli_archive: nuwax-cli-linux-arm64.tar.gz
            cross: true

          - name: Windows-x86_64
            os: [self-hosted, Windows, X64]
            rust_target: x86_64-pc-windows-msvc
            duck_cli_bin: nuwax-cli.exe
            duck_cli_archive: nuwax-cli-windows-amd64.zip
            cross: false

          - name: Windows-aarch64
            os: [self-hosted, Windows, X64]
            rust_target: aarch64-pc-windows-msvc
            duck_cli_bin: nuwax-cli.exe
            duck_cli_archive: nuwax-cli-windows-arm64.zip
            cross: false

          - name: macOS-x86_64
            os: macos-13  # ä½¿ç”¨ GitHub æ‰˜ç®¡çš„ Intel macOS runner
            rust_target: x86_64-apple-darwin
            duck_cli_bin: nuwax-cli
            duck_cli_archive: nuwax-cli-macos-amd64.tar.gz
            cross: false

          - name: macOS-aarch64
            os: [self-hosted, macOS, ARM64]
            rust_target: aarch64-apple-darwin
            duck_cli_bin: nuwax-cli
            duck_cli_archive: nuwax-cli-macos-arm64.tar.gz
            cross: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Linux dependencies (for Duck CLI build)
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        run: |
          echo "Installing Linux dependencies for Duck CLI build"
          
          # Update package lists
          sudo apt-get update
          
          # Install basic build dependencies
          sudo apt-get install -y \
            curl \
            wget \
            file \
            build-essential \
            libc6-dev \
            m4 \
            pkg-config \
            libglib2.0-dev \
            libglib2.0-0 \
            libglib2.0-data \
            libglib2.0-bin \
            glib-networking \
            glib-networking-common \
            glib-networking-services
          
          # Set PKG_CONFIG_PATH
          echo "PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV
          
          # Verify GLib installation
          echo "Verifying GLib dependencies..."
          pkg-config --exists glib-2.0 && echo "âœ… glib-2.0 found" || echo "âŒ glib-2.0 not found"

      - name: Setup WSL Ubuntu (for Linux builds on Windows)
        if: matrix.platform.use_wsl == true
        run: |
          Write-Host "Setting up WSL Ubuntu environment for Linux builds"
          
          # Enable WSL feature if not already enabled
          Write-Host "Enabling WSL feature..."
          try {
            Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux -NoRestart -All
            Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart -All
          } catch {
            Write-Host "WSL features may already be enabled or require restart"
          }
          
          # Set WSL 2 as default
          Write-Host "Setting WSL 2 as default..."
          wsl --set-default-version 2
          
          # Install Ubuntu if not present
          Write-Host "Checking for Ubuntu distribution..."
          $distributions = wsl --list --quiet 2>$null
          if (-not $distributions -or $distributions -notcontains "Ubuntu") {
            Write-Host "Installing Ubuntu distribution..."
            # Use winget to install Ubuntu if available
            try {
              winget install Canonical.Ubuntu.2204 --silent --accept-source-agreements --accept-package-agreements
            } catch {
              Write-Host "Winget failed, trying direct installation..."
              wsl --install Ubuntu --no-launch
            }
          } else {
            Write-Host "Ubuntu distribution found"
          }
          
          # Wait for WSL to be ready
          Start-Sleep -Seconds 10
          
          # Initialize Ubuntu (create default user if needed)
          Write-Host "Initializing Ubuntu..."
          try {
            wsl -d Ubuntu -- bash -c 'echo "Ubuntu initialized"'
          } catch {
            Write-Host "Ubuntu initialization may need interactive setup"
            # Try to run Ubuntu without user creation for CI
            wsl -d Ubuntu -u root -- bash -c 'echo "Running as root"'
          }
          
          # Update package lists
          Write-Host "Updating package lists..."
          wsl -d Ubuntu -u root -- bash -c 'export DEBIAN_FRONTEND=noninteractive && apt-get update'
          
          # Install basic dependencies
          Write-Host "Installing basic dependencies..."
          wsl -d Ubuntu -u root -- bash -c 'apt-get install -y curl build-essential pkg-config sudo'
          
          # Install Tauri Linux dependencies
          Write-Host "Installing Tauri dependencies..."
          wsl -d Ubuntu -u root -- bash -c 'apt-get install -y libwebkit2gtk-4.1-dev libwebkit2gtk-4.0-dev libjavascriptcoregtk-4.1-dev libjavascriptcoregtk-4.0-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev patchelf'
          
          # Install Rust
          Write-Host "Installing Rust..."
          wsl -d Ubuntu -u root -- bash -c 'curl --proto "=https" --tlsv1.2 -sSf https://sh.rustup.rs -o rustup.sh && chmod +x rustup.sh && ./rustup.sh -y && rm rustup.sh'
          
          # Add target architecture
          Write-Host "Adding target architecture..."
          wsl -d Ubuntu -u root -- bash -c 'source /root/.cargo/env && rustup target add ${{ matrix.platform.rust_target }}'
          
          # Verify installation
          Write-Host "Verifying installation..."
          wsl -d Ubuntu -u root -- bash -c 'source /root/.cargo/env && rustc --version && cargo --version'
        shell: powershell

      - name: Setup Windows Environment
        if: matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "Setting up Windows build environment"
          
          # Check and setup Git Bash environment
          if (Test-Path "C:\Program Files\Git\bin\bash.exe") {
            Write-Host "Found Git Bash: C:\Program Files\Git\bin\bash.exe"
            echo "C:\Program Files\Git\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } elseif (Test-Path "C:\Program Files (x86)\Git\bin\bash.exe") {
            Write-Host "Found Git Bash: C:\Program Files (x86)\Git\bin\bash.exe"
            echo "C:\Program Files (x86)\Git\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Host "Git Bash not found, using PowerShell instead"
          }
          
          # Verify bash availability
          try {
            $bashVersion = & bash --version 2>$null
            Write-Host "Bash version: $bashVersion"
          } catch {
            Write-Host "Bash not available, will use PowerShell for building"
          }
        shell: powershell

      - name: Install Visual Studio Build Tools (Windows - Duck CLI stage)
        if: matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "=== Duck CLI é˜¶æ®µï¼šå®‰è£… Visual Studio Build Tools ==="
          
          # Check if Visual Studio is already installed
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          $vsFound = $false
          
          if (Test-Path $vsWhere) {
            $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
            if ($vs) {
              Write-Host "âœ… Visual Studio found: $vs"
              $vsFound = $true
              
              # Setup environment for MSVC
              $vcvarsPath = "$vs\VC\Auxiliary\Build\vcvars64.bat"
              if (Test-Path $vcvarsPath) {
                Write-Host "Setting up MSVC environment with: $vcvarsPath"
                
                # Get environment variables from vcvars
                $vcvarsOutput = cmd /c "`"$vcvarsPath`" && set" 2>$null
                foreach ($line in $vcvarsOutput) {
                  if ($line -match "^([^=]+)=(.*)$") {
                    $name = $matches[1]
                    $value = $matches[2]
                    [Environment]::SetEnvironmentVariable($name, $value, "Process")
                  }
                }
                
                # Verify critical environment variables
                Write-Host "Verifying MSVC environment variables..."
                Write-Host "INCLUDE: $env:INCLUDE"
                Write-Host "LIB: $env:LIB"
                Write-Host "PATH additions: $($env:PATH -split ';' | Where-Object { $_ -like '*Visual Studio*' -or $_ -like '*VC*' -or $_ -like '*SDK*' })"
                
                Write-Host "âœ… MSVC environment configured"
              }
            }
          }
          
          if (-not $vsFound) {
            Write-Host "Installing Visual Studio Build Tools..."
            
            # Download VS Build Tools installer
            $installerPath = "$env:TEMP\vs_buildtools.exe"
            Write-Host "Downloading Visual Studio Build Tools installer..."
            Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vs_buildtools.exe" -OutFile $installerPath
            
            # Install with required components
            Write-Host "Installing Visual Studio Build Tools with MSVC support..."
            $installArgs = @(
              "--quiet",
              "--wait",
              "--add", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
              "--add", "Microsoft.VisualStudio.Component.VC.Tools.x64",
              "--add", "Microsoft.VisualStudio.Component.Windows11SDK.22000",
              "--add", "Microsoft.VisualStudio.Component.Windows10SDK.19041",
              "--add", "Microsoft.VisualStudio.Component.VC.Redist.14.Latest",
              "--add", "Microsoft.VisualStudio.Component.VC.CMake.Project"
            )
            
            # Add ARM64 support if building for ARM64
            if ("${{ matrix.platform.rust_target }}" -eq "aarch64-pc-windows-msvc") {
              $installArgs += "--add", "Microsoft.VisualStudio.Component.VC.Tools.ARM64"
              $installArgs += "--add", "Microsoft.VisualStudio.Component.VC.Tools.ARM64EC"
            }
            
            Start-Process -FilePath $installerPath -ArgumentList $installArgs -Wait
            
            Write-Host "âœ… Visual Studio Build Tools installation completed"
            
            # Setup environment for newly installed MSVC
            Write-Host "Setting up MSVC environment for newly installed tools..."
            $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            if (Test-Path $vsWhere) {
              $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
              if ($vs) {
                $vcvarsPath = "$vs\VC\Auxiliary\Build\vcvars64.bat"
                if (Test-Path $vcvarsPath) {
                  Write-Host "Setting up MSVC environment with: $vcvarsPath"
                  
                  # Get environment variables from vcvars
                  $vcvarsOutput = cmd /c "`"$vcvarsPath`" && set" 2>$null
                  foreach ($line in $vcvarsOutput) {
                    if ($line -match "^([^=]+)=(.*)$") {
                      $name = $matches[1]
                      $value = $matches[2]
                      [Environment]::SetEnvironmentVariable($name, $value, "Process")
                    }
                  }
                  
                  # Verify critical environment variables
                  Write-Host "Verifying MSVC environment variables..."
                  Write-Host "INCLUDE: $env:INCLUDE"
                  Write-Host "LIB: $env:LIB"
                  Write-Host "PATH additions: $($env:PATH -split ';' | Where-Object { $_ -like '*Visual Studio*' -or $_ -like '*VC*' -or $_ -like '*SDK*' })"
                  
                  Write-Host "âœ… MSVC environment configured"
                }
              }
            }
          }
          
          # Verify MSVC tools availability
          Write-Host "Verifying MSVC tools..."
          try {
            $clPath = Get-Command cl.exe -ErrorAction Stop
            Write-Host "âœ… cl.exe found: $($clPath.Source)"
            
            $libPath = Get-Command lib.exe -ErrorAction Stop
            Write-Host "âœ… lib.exe found: $($libPath.Source)"
            
            $linkPath = Get-Command link.exe -ErrorAction Stop
            Write-Host "âœ… link.exe found: $($linkPath.Source)"
          } catch {
            Write-Host "âŒ MSVC tools not found in PATH"
            Write-Host "Attempting to locate tools manually..."
            
            # Try to find tools manually
            $possiblePaths = @(
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\*\bin\Hostx64\x64"
            )
            
            foreach ($pattern in $possiblePaths) {
              $toolDirs = Get-ChildItem $pattern -ErrorAction SilentlyContinue
              if ($toolDirs) {
                $toolDir = $toolDirs | Sort-Object Name -Descending | Select-Object -First 1
                Write-Host "Found MSVC tools at: $($toolDir.FullName)"
                $env:PATH = "$($toolDir.FullName);$env:PATH"
                break
              }
            }
            
            # Re-verify after manual path addition
            try {
              $clPath = Get-Command cl.exe -ErrorAction Stop
              Write-Host "âœ… cl.exe found after manual search: $($clPath.Source)"
              
              $libPath = Get-Command lib.exe -ErrorAction Stop
              Write-Host "âœ… lib.exe found after manual search: $($libPath.Source)"
            } catch {
              Write-Error "âŒ Could not locate MSVC tools even after manual search"
              exit 1
            }
          }
          
          Write-Host "âœ… Visual Studio Build Tools setup completed for Duck CLI stage"
        shell: powershell

      - name: Install Rust toolchain (Windows)
        if: matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "Installing Rust toolchain"
          
          # Download and install Rust
          $rustupPath = Join-Path $env:TEMP "rustup-init.exe"
          
          try {
            # Use PowerShell to download and install Rust
            Write-Host "Downloading Rust installer..."
            Invoke-WebRequest -Uri "https://win.rustup.rs" -OutFile $rustupPath
            
            Write-Host "Installing Rust..."
            & $rustupPath -y --default-toolchain stable --default-host x86_64-pc-windows-msvc
            
            # Refresh environment variables
            $cargoPath = Join-Path $env:USERPROFILE ".cargo\bin"
            $env:PATH = "$cargoPath;$env:PATH"
            
            # Add target architecture
            Write-Host "Adding target architecture..."
            $rustupExe = Join-Path $cargoPath "rustup.exe"
            & $rustupExe target add ${{ matrix.platform.rust_target }}
            
            # Verify installation
            Write-Host "Verifying installation..."
            $rustcExe = Join-Path $cargoPath "rustc.exe"
            $cargoExe = Join-Path $cargoPath "cargo.exe"
            & $rustcExe --version
            & $cargoExe --version
            
            Write-Host "Rust toolchain installed successfully"
          } catch {
            Write-Host "Rust installation failed: $_"
            throw
          }
        shell: powershell

      - name: Install Rust toolchain (Linux)
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform.rust_target }}

      - name: Install Rust toolchain (macOS)
        if: matrix.platform.use_wsl != true && runner.os == 'macOS'
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform.rust_target }}

      - name: Setup macOS native environment (Duck CLI stage)
        if: matrix.platform.use_wsl != true && runner.os == 'macOS'
        run: |
          echo "=== Duck CLIé˜¶æ®µï¼šè®¾ç½®macOSåŽŸç”Ÿç¼–è¯‘çŽ¯å¢ƒ ==="
          
          # ç¡®ä¿Xcodeå·¥å…·
          if ! xcode-select -p &> /dev/null; then
            echo "Installing Xcode command line tools..."
            sudo xcode-select --install 2>/dev/null || echo "Xcode installation initiated"
            sleep 30
          fi
          
          # åŠ è½½RustçŽ¯å¢ƒ
          source ~/.cargo/env 2>/dev/null || true
          
          echo "Duck CLI stage - System: $(uname -m) -> Target: ${{ matrix.platform.rust_target }}"
          echo "Rust: $(rustc --version)"
          
          # å®‰è£…ç›®æ ‡
          if ! rustup target list --installed | grep -q "${{ matrix.platform.rust_target }}"; then
            echo "Installing target ${{ matrix.platform.rust_target }}..."
            rustup target add ${{ matrix.platform.rust_target }}
          fi
          
          # éªŒè¯ç›®æ ‡å®‰è£…æˆåŠŸ
          if rustup target list --installed | grep -q "${{ matrix.platform.rust_target }}"; then
            echo "âœ… Target ${{ matrix.platform.rust_target }} confirmed for Duck CLI"
          else
            echo "âŒ FATAL: Cannot install target for Duck CLI build"
            exit 1
          fi
          
          # è®¾ç½®çŽ¯å¢ƒå˜é‡
          echo "MACOSX_DEPLOYMENT_TARGET=10.15" >> $GITHUB_ENV
          
          echo "âœ… Duck CLI macOSçŽ¯å¢ƒå°±ç»ª"
        shell: bash

      - name: Install cross (for cross compilation - WSL)
        if: matrix.platform.cross && matrix.platform.use_wsl == true
        run: |
          Write-Host "Installing cross tool in WSL"
          wsl -d Ubuntu -u root -- bash -c 'source /root/.cargo/env && cargo install cross --git https://github.com/cross-rs/cross'
          Write-Host "Cross tool installed successfully"
        shell: powershell

      - name: Install cross (for cross compilation - Windows)
        if: matrix.platform.cross && matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "Installing cross tool"
          
          # Set environment variables
          $cargoPath = Join-Path $env:USERPROFILE ".cargo\bin"
          $env:PATH = "$cargoPath;$env:PATH"
          
          # Install cross tool
          Write-Host "Installing cross tool..."
          $cargoExe = Join-Path $cargoPath "cargo.exe"
          & $cargoExe install cross --git https://github.com/cross-rs/cross
          
          Write-Host "Cross tool installed successfully"
        shell: powershell

      - name: Install cross (for cross compilation - Linux)
        if: matrix.platform.cross && (matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64')
        run: |
          echo "Installing cross tool for Linux"
          cargo install cross --git https://github.com/cross-rs/cross
        shell: bash

      - name: Install cross (for cross compilation - macOS)
        if: matrix.platform.cross && matrix.platform.use_wsl != true && runner.os == 'macOS'
        run: |
          echo "Installing cross tool for macOS"
          cargo install cross --git https://github.com/cross-rs/cross
        shell: bash

      - name: Cache cargo (WSL)
        if: matrix.platform.use_wsl == true
        uses: actions/cache@v4
        with:
          path: |
            ~/cargo-cache-wsl
          key: ${{ runner.os }}-wsl-${{ matrix.platform.rust_target }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo (Windows)
        if: matrix.platform.use_wsl != true
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ matrix.platform.rust_target }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Build Duck CLI binary (WSL)
        if: matrix.platform.use_wsl == true
        run: |
          Write-Host "Building Duck CLI in WSL Ubuntu"
          
          # Get current workspace path in WSL format
          $currentPath = Get-Location
          $wslPath = $currentPath.Path -replace 'C:\\', '/mnt/c/' -replace '\\', '/'
          
          if ('${{ matrix.platform.cross }}' -eq 'true') {
            Write-Host "Using cross tool to build Duck CLI"
            wsl -d Ubuntu -u root -- bash -c "source /root/.cargo/env && cd '$wslPath' && cross build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli"
          } else {
            Write-Host "Building Duck CLI locally"
            wsl -d Ubuntu -u root -- bash -c "source /root/.cargo/env && cd '$wslPath' && cargo build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli"
          }
          
          Write-Host "Duck CLI build completed"
        shell: powershell

      - name: Build Duck CLI binary (Windows)
        if: matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "Building Duck CLI binary with MSVC"
          
          # Set environment variables
          $cargoPath = Join-Path $env:USERPROFILE ".cargo\bin"
          $env:PATH = "$cargoPath;$env:PATH"
          
          # Ensure MSVC tools and include paths are properly configured
          Write-Host "Verifying MSVC tools and environment before build..."
          try {
            $clPath = Get-Command cl.exe -ErrorAction Stop
            Write-Host "âœ… cl.exe available: $($clPath.Source)"
            
            $libPath = Get-Command lib.exe -ErrorAction Stop
            Write-Host "âœ… lib.exe available: $($libPath.Source)"
          } catch {
            Write-Host "âŒ MSVC tools not found, attempting to fix PATH..."
            
            # Try to find and add MSVC tools to PATH
            $possiblePaths = @(
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\*\bin\Hostx64\x64",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\*\bin\Hostx64\x64"
            )
            
            foreach ($pattern in $possiblePaths) {
              $toolDirs = Get-ChildItem $pattern -ErrorAction SilentlyContinue
              if ($toolDirs) {
                $toolDir = $toolDirs | Sort-Object Name -Descending | Select-Object -First 1
                Write-Host "Adding MSVC tools to PATH: $($toolDir.FullName)"
                $env:PATH = "$($toolDir.FullName);$env:PATH"
                break
              }
            }
          }
          
          # Verify and fix INCLUDE and LIB paths if needed
          Write-Host "Checking INCLUDE and LIB environment variables..."
          if (-not $env:INCLUDE -or $env:INCLUDE -eq "") {
            Write-Host "âŒ INCLUDE path not set, attempting to fix..."
            
            # Find Visual Studio installation and setup environment
            $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            if (Test-Path $vsWhere) {
              $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
              if ($vs) {
                Write-Host "Re-running vcvars64.bat to fix environment..."
                $vcvarsPath = "$vs\VC\Auxiliary\Build\vcvars64.bat"
                if (Test-Path $vcvarsPath) {
                  # Re-run vcvars and apply environment
                  $vcvarsOutput = cmd /c "`"$vcvarsPath`" && set" 2>$null
                  foreach ($line in $vcvarsOutput) {
                    if ($line -match "^([^=]+)=(.*)$") {
                      $name = $matches[1]
                      $value = $matches[2]
                      [Environment]::SetEnvironmentVariable($name, $value, "Process")
                    }
                  }
                }
              }
            }
          }
          
          Write-Host "Final environment check:"
          Write-Host "INCLUDE: $env:INCLUDE"
          Write-Host "LIB: $env:LIB"
          
          if (-not $env:INCLUDE) {
            Write-Error "âŒ INCLUDE environment variable is still not set. This will cause C compilation to fail."
            exit 1
          }
          
          # Set Rust environment variables for MSVC
          Write-Host "Configuring Rust for MSVC..."
          $env:CC = "cl.exe"
          $env:CXX = "cl.exe"
          $env:AR = "lib.exe"
          
          # Additional environment variables for Windows compilation
          if ("${{ matrix.platform.rust_target }}" -eq "aarch64-pc-windows-msvc") {
            Write-Host "Configuring for ARM64 target"
            $env:CARGO_TARGET_AARCH64_PC_WINDOWS_MSVC_LINKER = "rust-lld.exe"
            
            # For ARM64, we need to ensure we use the right vcvars script
            $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            if (Test-Path $vsWhere) {
              $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
              if ($vs) {
                $vcvarsARM64Path = "$vs\VC\Auxiliary\Build\vcvarsx86_arm64.bat"
                if (Test-Path $vcvarsARM64Path) {
                  Write-Host "Setting up ARM64 cross-compilation environment with: $vcvarsARM64Path"
                  $vcvarsOutput = cmd /c "`"$vcvarsARM64Path`" && set" 2>$null
                  foreach ($line in $vcvarsOutput) {
                    if ($line -match "^([^=]+)=(.*)$") {
                      $name = $matches[1]
                      $value = $matches[2]
                      [Environment]::SetEnvironmentVariable($name, $value, "Process")
                    }
                  }
                  Write-Host "ARM64 cross-compilation environment configured"
                }
              }
            }
          }
          
          # Choose build method
          if ('${{ matrix.platform.cross }}' -eq 'true') {
            Write-Host "Using cross tool to build Duck CLI"
            $crossExe = Join-Path $cargoPath "cross.exe"
            & $crossExe build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli
          } else {
            Write-Host "Building Duck CLI locally with target: ${{ matrix.platform.rust_target }}"
            $cargoExe = Join-Path $cargoPath "cargo.exe"
            & $cargoExe build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli
          }
          
          # Verify the built binary
          $binaryPath = "target\${{ matrix.platform.rust_target }}\release\${{ matrix.platform.duck_cli_bin }}"
          if (Test-Path $binaryPath) {
            Write-Host "âœ… Duck CLI binary built successfully: $binaryPath"
            $binaryInfo = Get-Item $binaryPath
            Write-Host "Binary size: $($binaryInfo.Length) bytes"
          } else {
            Write-Error "âŒ Duck CLI binary not found at expected path: $binaryPath"
            exit 1
          }
          
          Write-Host "Duck CLI build completed"
        shell: powershell

      - name: Build Duck CLI binary (Linux)
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        run: |
          echo "Building Duck CLI for Linux"
          
          # Set environment variables for Linux builds
          export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/lib/pkgconfig:$PKG_CONFIG_PATH"
          export PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1
          export PKG_CONFIG_ALLOW_SYSTEM_LIBS=1
          
          # Verify glib dependencies
          echo "Verifying glib dependencies..."
          pkg-config --exists glib-2.0 && echo "âœ… glib-2.0 available" || echo "âŒ glib-2.0 not found"
          
          # Choose build method
          if [ "${{ matrix.platform.cross }}" = "true" ]; then
            echo "Using cross tool for cross compilation"
            echo "Target architecture: ${{ matrix.platform.rust_target }}"
            cross build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli
          else
            echo "Building natively for ${{ matrix.platform.rust_target }}"
            cargo build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli
          fi
          
          echo "Duck CLI build completed successfully"
        shell: bash

      - name: Build Duck CLI binary (macOS)
        if: matrix.platform.use_wsl != true && runner.os == 'macOS'
        run: |
          echo "Building Duck CLI for macOS"
          
          # Environment variables should already be set in previous step, but let's verify and set them again if needed
          if [ "${{ matrix.platform.rust_target }}" = "x86_64-apple-darwin" ]; then
            echo "Configuring ARM64 -> x86_64 cross-compilation"
            export MACOSX_DEPLOYMENT_TARGET=10.15
            export CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER=clang
            export CC_x86_64_apple_darwin=clang
            export CXX_x86_64_apple_darwin=clang++
            export AR_x86_64_apple_darwin=ar
            export CFLAGS_x86_64_apple_darwin="-arch x86_64"
            export CXXFLAGS_x86_64_apple_darwin="-arch x86_64"
            
            # Verify cross-compilation environment
            echo "Cross-compilation environment:"
            echo "MACOSX_DEPLOYMENT_TARGET: $MACOSX_DEPLOYMENT_TARGET"
            echo "CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER: $CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER"
          else
            echo "Configuring native ARM64 compilation"
            export MACOSX_DEPLOYMENT_TARGET=11.0
            echo "MACOSX_DEPLOYMENT_TARGET: $MACOSX_DEPLOYMENT_TARGET"
          fi
          
          # Verify target is available
          echo "Verifying target availability..."
          if rustup target list --installed | grep -q "${{ matrix.platform.rust_target }}"; then
            echo "âœ… Target ${{ matrix.platform.rust_target }} is available"
          else
            echo "âŒ Target ${{ matrix.platform.rust_target }} is not available"
            echo "Installed targets:"
            rustup target list --installed
            exit 1
          fi
          
          # Test cross-compilation setup
          echo "Testing cross-compilation setup..."
          rustc --print cfg --target ${{ matrix.platform.rust_target }}
          
          # Build Duck CLI
          echo "Building Duck CLI for target: ${{ matrix.platform.rust_target }}"
          cargo build --release --target ${{ matrix.platform.rust_target }} -p nuwax-cli
          
          echo "Duck CLI build completed successfully"
        shell: bash

      - name: Package Duck CLI binary (Windows)
        if: matrix.platform.name == 'Windows-x86_64' || matrix.platform.name == 'Windows-aarch64'
        run: |
          # è¿›å…¥æž„å»ºç›®å½•
          Push-Location "target/${{ matrix.platform.rust_target }}/release"
          
          # ä½¿ç”¨ PowerShell å†…ç½®åŽ‹ç¼©åŠŸèƒ½ä»£æ›¿ 7z
          Write-Host "Compressing ${{ matrix.platform.duck_cli_bin }} to ${{ matrix.platform.duck_cli_archive }}"
          Compress-Archive -Path ${{ matrix.platform.duck_cli_bin }} -DestinationPath "../../../${{ matrix.platform.duck_cli_archive }}" -Force
          
          # è¿”å›žåŽŸç›®å½•
          Pop-Location
          
          # éªŒè¯æ–‡ä»¶åˆ›å»º
          if (Test-Path "${{ matrix.platform.duck_cli_archive }}") {
            Write-Host "Archive created successfully: ${{ matrix.platform.duck_cli_archive }}"
            Get-Item "${{ matrix.platform.duck_cli_archive }}" | Format-List Name, Length
          } else {
            Write-Error "Failed to create archive: ${{ matrix.platform.duck_cli_archive }}"
            exit 1
          }
        shell: powershell

      - name: Package Duck CLI binary (Linux)
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        run: |
          cd target/${{ matrix.platform.rust_target }}/release
          tar czf ../../../${{ matrix.platform.duck_cli_archive }} ${{ matrix.platform.duck_cli_bin }}
          cd -
        shell: bash

      - name: Package Duck CLI binary (macOS)
        if: matrix.platform.name == 'macOS-x86_64' || matrix.platform.name == 'macOS-aarch64'
        run: |
          cd target/${{ matrix.platform.rust_target }}/release
          tar czf ../../../${{ matrix.platform.duck_cli_archive }} ${{ matrix.platform.duck_cli_bin }}
          cd -
        shell: bash



      - name: Upload Duck CLI artifact (for sidecar)
        uses: actions/upload-artifact@v4
        with:
          name: nuwax-cli-${{ matrix.platform.name }}
          path: ${{ matrix.platform.duck_cli_archive }}
          retention-days: 1

  # ä½¿ç”¨å®˜æ–¹ tauri-action æž„å»º CLI-UI æ¡Œé¢åº”ç”¨
  build-cli-ui:
    name: Build CLI-UI for ${{ matrix.platform.name }}
    runs-on: ${{ matrix.platform.os }}
    needs: [check-versions, build-nuwax-cli]
    if: needs.check-versions.outputs.should_build == 'true'
    strategy:
      fail-fast: false
      matrix:
        platform:
          - name: Linux-x86_64
            os: ubuntu-22.04
            rust_target: x86_64-unknown-linux-gnu
            duck_cli_artifact: nuwax-cli-Linux-x86_64

          - name: Windows-x86_64
            os: [self-hosted, Windows, X64]
            rust_target: x86_64-pc-windows-msvc
            duck_cli_artifact: nuwax-cli-Windows-x86_64

          - name: macOS-x86_64
            os: macos-13  # ä½¿ç”¨ GitHub æ‰˜ç®¡çš„ Intel macOS runner
            rust_target: x86_64-apple-darwin
            duck_cli_artifact: nuwax-cli-macOS-x86_64

          - name: macOS-aarch64
            os: [self-hosted, macOS, ARM64]
            rust_target: aarch64-apple-darwin
            duck_cli_artifact: nuwax-cli-macOS-aarch64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'yarn'
          cache-dependency-path: cli-ui/yarn.lock


      - name: Install Linux dependencies
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libwebkit2gtk-4.0-dev \
            libjavascriptcoregtk-4.1-dev \
            libjavascriptcoregtk-4.0-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Cache Linux dependencies
        if: matrix.platform.name == 'Linux-x86_64' || matrix.platform.name == 'Linux-aarch64'
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Setup WSL Ubuntu (for Linux builds on Windows)
        if: matrix.platform.use_wsl == true
        run: |
          Write-Host "Setting up WSL Ubuntu environment for Linux GUI builds"
          
          # WSL should already be set up in Duck CLI build stage, here we just need to install Node.js
          Write-Host "Checking and installing Node.js..."
          $nodeInstalled = wsl -d Ubuntu -u root -- bash -c 'command -v node > /dev/null 2>&1 && echo "installed" || echo "not-installed"'
          if ($nodeInstalled -eq "not-installed") {
            Write-Host "Installing Node.js..."
            wsl -d Ubuntu -u root -- bash -c 'curl -fsSL https://deb.nodesource.com/setup_lts.x -o nodesource_setup.sh'
            wsl -d Ubuntu -u root -- bash -c 'bash nodesource_setup.sh'
            wsl -d Ubuntu -u root -- bash -c 'apt-get install -y nodejs'
            wsl -d Ubuntu -u root -- bash -c 'rm nodesource_setup.sh'
          } else {
            Write-Host "Node.js already installed"
          }
          
          # Install Yarn
          Write-Host "Checking and installing Yarn..."
          $yarnInstalled = wsl -d Ubuntu -u root -- bash -c 'command -v yarn > /dev/null 2>&1 && echo "installed" || echo "not-installed"'
          if ($yarnInstalled -eq "not-installed") {
            Write-Host "Installing Yarn..."
            wsl -d Ubuntu -u root -- bash -c 'npm install -g yarn'
          } else {
            Write-Host "Yarn already installed"
          }
          
          # Verify installation
          Write-Host "Verifying installation..."
          wsl -d Ubuntu -u root -- bash -c 'node --version'
          wsl -d Ubuntu -u root -- bash -c 'yarn --version'
          wsl -d Ubuntu -u root -- bash -c 'source /root/.cargo/env && rustc --version'
        shell: powershell

      - name: Install Rust toolchain (Windows/macOS) 
        if: matrix.platform.use_wsl != true
        run: |
          echo "=== Installing Rust Toolchain ==="
          
          # ä½¿ç”¨ dtolnay/rust-toolchain action å·²ç»å®‰è£…äº† Rustï¼Œåªéœ€è¦éªŒè¯
          if command -v rustup &> /dev/null; then
            echo "Rust toolchain already installed"
          else
            echo "Installing fresh Rust toolchain..."
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --profile default
            source ~/.cargo/env
          fi
          
          # å®‰è£…ç›®æ ‡
          echo "Installing target: ${{ matrix.platform.rust_target }}"
          rustup target add ${{ matrix.platform.rust_target }}
          
          # éªŒè¯å®‰è£…
          echo "=== Verification ==="
          echo "Rust: $(rustc --version)"
          echo "Installed targets:"
          rustup target list --installed
          
          if rustup target list --installed | grep -q "${{ matrix.platform.rust_target }}"; then
            echo "âœ… Target ${{ matrix.platform.rust_target }} confirmed!"
          else
            echo "âŒ Target verification failed!"
            exit 1
          fi
          
          echo "âœ… Rust toolchain ready!"
        shell: bash

      - name: Setup macOS environment (CLI-UI stage)
        if: matrix.platform.name == 'macOS-x86_64'
        run: |
          echo "=== macOS åŽŸç”Ÿç¼–è¯‘çŽ¯å¢ƒå‡†å¤‡ ==="
          
          # åŠ è½½RustçŽ¯å¢ƒ
          source ~/.cargo/env 2>/dev/null || true
          
          echo "System: $(uname -m) -> Target: x86_64"
          echo "Rust: $(rustc --version)"
          
          # ç¡®ä¿ç›®æ ‡å·²å®‰è£…
          if ! rustup target list --installed | grep -q "x86_64-apple-darwin"; then
            echo "Installing x86_64-apple-darwin target..."
            rustup target add x86_64-apple-darwin
          fi
          
          # éªŒè¯ç›®æ ‡å®‰è£…
          if rustup target list --installed | grep -q "x86_64-apple-darwin"; then
            echo "âœ… x86_64-apple-darwin target confirmed"
          else
            echo "âŒ Target installation failed!"
            exit 1
          fi
          
          # è®¾ç½®çŽ¯å¢ƒå˜é‡
          echo "MACOSX_DEPLOYMENT_TARGET=10.15" >> $GITHUB_ENV
          
          echo "âœ… macOSçŽ¯å¢ƒå‡†å¤‡å®Œæˆï¼"

      - name: Setup macOS native environment (CLI-UI stage)
        if: matrix.platform.name == 'macOS-aarch64'
        run: |
          echo "Setting up native ARM64 compilation for CLI-UI build"
          
          # Verify Xcode command line tools
          if ! xcode-select -p &> /dev/null; then
            echo "Installing Xcode command line tools..."
            xcode-select --install
            sleep 30
          fi
          
          # Ensure target architecture is installed
          echo "Installing aarch64-apple-darwin target..."
          rustup target add aarch64-apple-darwin
          
          # Verify target installation
          if rustup target list --installed | grep -q "aarch64-apple-darwin"; then
            echo "âœ… aarch64-apple-darwin target successfully installed"
          else
            echo "âŒ aarch64-apple-darwin target installation failed"
            exit 1
          fi
          
          # Set environment variables for native ARM64
          echo "MACOSX_DEPLOYMENT_TARGET=11.0" >> $GITHUB_ENV
          
          echo "Native ARM64 environment ready"
          echo "Current system architecture: $(uname -m)"
          echo "Target architecture: aarch64"
          echo "Rust target: aarch64-apple-darwin"
          echo "Rust toolchain: $(rustc --version)"

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            cli-ui/src-tauri/target
          key: ${{ runner.os }}-${{ matrix.platform.rust_target }}-cargo-cli-ui-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.platform.rust_target }}-cargo-cli-ui-
            ${{ runner.os }}-${{ matrix.platform.rust_target }}-cargo-

      - name: Install frontend dependencies (Linux)
        if: matrix.platform.name == 'Linux-x86_64'
        run: |
          echo "Installing frontend dependencies (Linux environment)"
          cd cli-ui
          yarn install
          echo "Frontend dependencies installed successfully"
        shell: bash

      - name: Install Visual Studio Build Tools for ARM64
        if: matrix.platform.name == 'Windows-aarch64'
        run: |
          Write-Host "Checking for Visual Studio Build Tools..."
          
          # Check if Visual Studio is already installed
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          $vsFound = $false
          
          if (Test-Path $vsWhere) {
            $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
            if ($vs) {
              Write-Host "âœ… Visual Studio found: $vs"
              $vsFound = $true
            }
          }
          
          if (-not $vsFound) {
            Write-Host "Installing Visual Studio Build Tools..."
            
            # Download VS Build Tools installer
            $installerPath = "$env:TEMP\vs_buildtools.exe"
            Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vs_buildtools.exe" -OutFile $installerPath
            
            # Install with ARM64 support
            Write-Host "Installing Visual Studio Build Tools with ARM64 support..."
            Start-Process -FilePath $installerPath -ArgumentList @(
              "--quiet",
              "--wait",
              "--add", "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
              "--add", "Microsoft.VisualStudio.Component.VC.Tools.ARM64",
              "--add", "Microsoft.VisualStudio.Component.Windows10SDK.19041"
            ) -Wait
            
            Write-Host "âœ… Visual Studio Build Tools installation completed"
          }
        shell: powershell

      - name: Setup Windows ARM64 cross-compilation
        if: matrix.platform.name == 'Windows-aarch64'
        run: |
          Write-Host "Setting up Windows ARM64 cross-compilation"
          
          # Setup Visual Studio Environment for ARM64 cross-compilation
          Write-Host "Setting up Visual Studio environment for ARM64..."
          
          # Find Visual Studio installation
          $vsWhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vsWhere) {
            $vs = & $vsWhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
            if ($vs) {
              Write-Host "âœ… Visual Studio found: $vs"
              
              # Setup environment for x64 host, ARM64 target
              $vcvarsPath = "$vs\VC\Auxiliary\Build\vcvarsx86_arm64.bat"
              if (-not (Test-Path $vcvarsPath)) {
                $vcvarsPath = "$vs\VC\Auxiliary\Build\vcvars64.bat"
              }
              
              if (Test-Path $vcvarsPath) {
                Write-Host "Setting up MSVC environment with: $vcvarsPath"
                
                # Get environment variables from vcvars
                $vcvarsOutput = cmd /c "`"$vcvarsPath`" && set" 2>$null
                foreach ($line in $vcvarsOutput) {
                  if ($line -match "^([^=]+)=(.*)$") {
                    $name = $matches[1]
                    $value = $matches[2]
                    [Environment]::SetEnvironmentVariable($name, $value, "Process")
                  }
                }
                
                Write-Host "âœ… MSVC environment configured"
              } else {
                Write-Warning "vcvars script not found"
              }
            } else {
              Write-Warning "Visual Studio not found"
            }
          } else {
            Write-Warning "vswhere.exe not found"
          }
          
          # Add ARM64 target for Rust
          Write-Host "Adding ARM64 Rust target..."
          rustup target add aarch64-pc-windows-msvc
          
          # Verify target installation
          $installedTargets = rustup target list --installed
          if ($installedTargets -match "aarch64-pc-windows-msvc") {
            Write-Host "âœ… aarch64-pc-windows-msvc target installed successfully"
          } else {
            Write-Error "âŒ Failed to install aarch64-pc-windows-msvc target"
            exit 1
          }
          
          # Set Rust environment variables for MSVC
          Write-Host "Configuring Rust environment for MSVC..."
          $env:CC = "cl.exe"
          $env:CXX = "cl.exe"
          $env:AR = "lib.exe"
          
          # Verify compiler availability
          Write-Host "Verifying compiler setup..."
          try {
            $clPath = Get-Command cl.exe -ErrorAction Stop
            Write-Host "âœ… MSVC compiler found: $($clPath.Source)"
            
            # Test basic compilation
            Write-Host "Testing compilation..."
            $testResult = cl.exe 2>&1
            Write-Host "Compiler test result: $testResult"
          } catch {
            Write-Host "âŒ MSVC compiler not accessible"
            Write-Host "PATH: $env:PATH"
            
            # Try to find cl.exe manually
            $possiblePaths = @(
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\*\bin\Hostx64\x64\cl.exe",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\*\bin\Hostx64\x64\cl.exe",
              "${env:ProgramFiles}\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\*\bin\Hostx64\x64\cl.exe",
              "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\*\bin\Hostx64\x64\cl.exe"
            )
            
            foreach ($pattern in $possiblePaths) {
              $found = Get-ChildItem $pattern -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                Write-Host "Found compiler at: $($found.FullName)"
                $compilerDir = Split-Path $found.FullName
                $env:PATH = "$compilerDir;$env:PATH"
                break
              }
            }
          }
          
          Write-Host "Windows ARM64 cross-compilation environment ready"
        shell: powershell

      - name: Install frontend dependencies (Windows)
        if: matrix.platform.use_wsl != true && runner.os == 'Windows'
        run: |
          Write-Host "Installing frontend dependencies"
          cd cli-ui
          yarn install
          Write-Host "Frontend dependencies installed successfully"
        shell: powershell

      - name: Install frontend dependencies (macOS)
        if: matrix.platform.use_wsl != true && runner.os == 'macOS'
        run: |
          cd cli-ui
          yarn install

      - name: Download Duck CLI artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.platform.duck_cli_artifact }}
          path: duck-cli-artifacts/

      - name: Setup Duck CLI sidecar (Windows)
        if: matrix.platform.name == 'Windows-x86_64' || matrix.platform.name == 'Windows-aarch64'
        run: |
          # Create sidecar directory
          New-Item -ItemType Directory -Force -Path "cli-ui/src-tauri/binaries"
          
          # Extract nuwax-cli to temporary directory
          cd duck-cli-artifacts
          
          # ä½¿ç”¨ PowerShell å†…ç½®è§£åŽ‹ç¼©åŠŸèƒ½ä»£æ›¿ 7z
          $zipFile = Get-ChildItem -Filter "*.zip" | Select-Object -First 1
          Write-Host "Extracting $($zipFile.Name)"
          Expand-Archive -Path $zipFile.FullName -DestinationPath "." -Force
          
          # ç§»åŠ¨äºŒè¿›åˆ¶æ–‡ä»¶
          Move-Item nuwax-cli.exe "../cli-ui/src-tauri/binaries/nuwax-cli-${{ matrix.platform.rust_target }}.exe"
          
          # Verify sidecar files
          Write-Host "Verifying sidecar files"
          Get-ChildItem "../cli-ui/src-tauri/binaries/"
        shell: powershell

      - name: Setup Duck CLI sidecar (Linux)
        if: matrix.platform.name == 'Linux-x86_64'
        run: |
          echo "Setting up Duck CLI sidecar (Linux environment)"
          
          # Create sidecar directory
          mkdir -p cli-ui/src-tauri/binaries
          
          # Extract nuwax-cli to temporary directory
          cd duck-cli-artifacts
          tar -xzf *.tar.gz
          mv nuwax-cli "../cli-ui/src-tauri/binaries/nuwax-cli-${{ matrix.platform.rust_target }}"
          
          # Verify sidecar files
          echo "Verifying sidecar files"
          ls -la "../cli-ui/src-tauri/binaries/"
        shell: bash

      - name: Setup Duck CLI sidecar (macOS)
        if: matrix.platform.name == 'macOS-x86_64' || matrix.platform.name == 'macOS-aarch64'
        run: |
          # Create sidecar directory
          mkdir -p cli-ui/src-tauri/binaries
          
          # Extract nuwax-cli to temporary directory
          cd duck-cli-artifacts
          tar -xzf *.tar.gz
          mv nuwax-cli "../cli-ui/src-tauri/binaries/nuwax-cli-${{ matrix.platform.rust_target }}"
          
          # Verify sidecar files
          echo "Verifying sidecar files"
          ls -la "../cli-ui/src-tauri/binaries/"
        shell: bash



      - name: Build CLI-UI with Tauri Action
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
          # ä¼˜åŒ–ç¼–è¯‘æ€§èƒ½
          CARGO_TERM_COLOR: always
          CARGO_INCREMENTAL: 0
          CARGO_NET_RETRY: 10
          # å‡å°‘æ—¥å¿—è¾“å‡ºä»¥æå‡æ€§èƒ½
          RUST_BACKTRACE: short
          # macOS ç¼–è¯‘çŽ¯å¢ƒå˜é‡
          MACOSX_DEPLOYMENT_TARGET: ${{ matrix.platform.name == 'macOS-x86_64' && '10.15' || '11.0' }}
          # ç§»é™¤ debug æ—¥å¿—ä»¥å‡å°‘ I/O å¼€é”€
          # RUST_LOG: debug
        with:
          projectPath: cli-ui
          # ç§»é™¤ --verbose å‚æ•°å‡å°‘æ—¥å¿—è¾“å‡º
          args: --target ${{ matrix.platform.rust_target }}
          tagName: ${{ needs.check-versions.outputs.cli_ui_should_release == 'true' && needs.check-versions.outputs.cli_ui_tag_name || '' }}
          releaseName: ${{ needs.check-versions.outputs.cli_ui_should_release == 'true' && format('Duck CLI GUI v{0}', needs.check-versions.outputs.cli_ui_version) || '' }}
          releaseBody: ${{ needs.check-versions.outputs.cli_ui_should_release == 'true' && format('Duck CLI GUI {0} å‘å¸ƒè¯´æ˜Ž', needs.check-versions.outputs.cli_ui_version) || '' }}
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: true







  # æž„å»ºæ‘˜è¦
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [check-versions, build-nuwax-cli, build-cli-ui]
    if: ${{ always() }}
    steps:
      - name: Generate build summary
        run: |
          echo "## ðŸš€ Unified Build & Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“‹ Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **CLI-UI**: ${{ needs.check-versions.outputs.cli_ui_version || 'Not checked' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ”„ Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- Duck CLI build: ${{ needs.build-nuwax-cli.result == 'success' && 'âœ… Completed' || needs.build-nuwax-cli.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- CLI-UI build: ${{ needs.build-cli-ui.result == 'success' && 'âœ… Completed' || needs.build-cli-ui.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“¦ Release Status" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.check-versions.outputs.cli_ui_should_release }}" == "true" ]]; then
            echo "- ðŸ–¥ï¸ **CLI-UI ${{ needs.check-versions.outputs.cli_ui_version }}** has been released!" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ”— [Download CLI-UI](${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.check-versions.outputs.cli_ui_tag_name }})" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ”„ Automatic updates enabled in the app (via official Tauri updater)" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ“ Signatures automatically included by tauri-action" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ¦† Duck CLI integrated as sidecar binary" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ðŸ–¥ï¸ CLI-UI: No new version to release" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Supported Platforms" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ–¥ï¸ Duck CLI GUI (Desktop Application)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ§ Linux (x86_64) - AppImage" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸªŸ Windows (x86_64, ARM64) - MSI Installer" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŽ macOS (x86_64, Apple Silicon) - DMG Package" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note**: Duck CLI is integrated as a sidecar binary and doesn't require separate installation." >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ’¡ Usage Instructions" >> $GITHUB_STEP_SUMMARY
          echo "#### To release new versions:" >> $GITHUB_STEP_SUMMARY
          echo "- **Update version**: Modify \`cli-ui/src-tauri/tauri.conf.json\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit and push**: Changes to main branch trigger automatic release" >> $GITHUB_STEP_SUMMARY
          echo "- **Duck CLI**: Automatically built and integrated as sidecar" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### ðŸ”„ Automatic Updates:" >> $GITHUB_STEP_SUMMARY
          echo "- Built-in Tauri updater with signature verification" >> $GITHUB_STEP_SUMMARY
          echo "- Updates checked and applied automatically within the app" >> $GITHUB_STEP_SUMMARY
          echo "- Duck CLI updates included with GUI releases" >> $GITHUB_STEP_SUMMARY